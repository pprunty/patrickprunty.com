import { SITE_URL } from '@/config';

export const metadata = {
  title: "Where's the Makefile?",
  description:
    'Exploring the lack of Makefiles used in industry and arguing why they should be standard for every software repository and project.',
  image: '/images/where-the-makefile/makefile.webp',
  date: '2024-11-07',
  author: 'Patrick Prunty',
  authorUrl: 'https://patrickprunty.com/about',
  openGraph: {
    title: "Where's the Makefile?",
    description:
      'Exploring the lack of Makefiles used in industry and arguing why they should be standard for every software repository and project.',
    url: '/blog/where-the-makefile',
    images: [
      {
        url: `${SITE_URL}/images/where-the-makefile/makefile.webp`,
        alt: "Where's the Makefile?",
      },
    ],
    type: 'article',
    tags: [
      'programming',
      'makefile',
      'GNU',
      'software developement',
      'technology',
      'industry standards',
    ],
  },
  twitter: {
    card: 'summary_large_image',
    title: "Where's the Makefile?",
    description:
      'Exploring the lack of Makefiles used in industry and arguing why they should be standard for every software repository and project.',
    image: `${SITE_URL}/images/where-the-makefile/makefile.webp`,
  },
  keywords: [
    'programming',
    'makefile',
    'GNU',
    'software developement',
    'technology',
    'industry standards',
  ],
  slug: 'where-the-makefile',
  readingTime: 2,
  draft: true,
};

Wouldn't it be so easy?

Imagine a world wherein everytime you are introduced to a new code base, the quickstart section of the
documentation reads:

```makefile
To install, build and run the project, run:

$ make run
```

And so, you open up the project, run the `make run` command and BOOM. The application starts running.

That's the power the Makefile gives you and your team.

# What is a Makefile? [#what-is-a-makefile]

A Makefile is a file which sits at the root of your project.

It should _always_ be called 'Makefile', no file extension is required.

The Makefile collects the commands you should use to run your project.

It enables team members, new and old, to get a project up-and-running quickly, determine its state and get to work on
developing within the project structure **without** having to know the nuances of how to actually install, build and run the
application.

Image you have a simple python project, you know that to run the project you need to run:

```bash
python main.py
```

To install the requirements for the project, you know you

Putting it all together, you can check if the user has a venv created, create it.

# What are Pre-Required Software?

This question is often asked in regards to

Oh, but what if you need to install required software before running the command, say, for example for a
NextJS 15 project?

The requirements for NextJS are:

- `node`
- `docker` (optional)

So can simply do this in your Makefile:

```bash

NODE_INSTALL=
DOCKER_INSTALL=

# Development server
.PHONY: run
dev:
	npm run dev --turbo

# Build the project
.PHONY: build
build: lint
	NODE_ENV=$(NODE_ENV) npm run build

# Install dependencies
.PHONY: install
install:
	npm install

# Help
.PHONY: help
help:
	@echo "Usage: make [target]"
	@echo ""
	@echo "Targets:"
	@echo "  run        Start the development server"
	@echo "  build      Build the project for production"
	@echo "  install    Install dependencies"
```

# Makefile and Docker [#makefile-and-docker]

# Makefiles are Monsters [#makefiles-are-monsters]

If I haven't already convinced you, _Makefiles are monsters_.

They should be industry standard and maintained by developers on every project.

Not to mention,
with the advance of LLM (Large Language Models), a Makefile provides a one-stop-shop for an artificially intelligent
agent to discover, clone and run a project.
